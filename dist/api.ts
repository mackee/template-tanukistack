// This file was automatically @generated by gentypescript

type apiSchemaCollection = {
  "GET /api/hello": {
    Query: {
      name: string;
    }
    Request: undefined
    Response: {
      message: string;
    } | { error: { message: string } }
  };
  "GET /api/messages": {
    Query: {
      start_id?: string;
    }
    Request: undefined
    Response: {
      messages: {
        id: string;
        author: string;
        text: string;
        created_at: string;
        updated_at: string;
      }[];
    } | { error: { message: string } }
  };
  "POST /api/messages": {
    Query: undefined
    Request: {
      author: string;
      text: string;
    }
    Response: {
      message?: {
        id: string;
        author: string;
        text: string;
        created_at: string;
        updated_at: string;
      };
    } | { error: { message: string } }
  };
};

export const isErrorResponse = (response: unknown): response is { error: { message: string } } => {
  return !!((response as { error: unknown })?.error)
};

type method = keyof apiSchemaCollection extends `${infer M} ${string}` ? M : never;
type methodPathsByMethod<M extends method> = Extract<keyof apiSchemaCollection, `${M} ${string}`>;
type pathByMethod<MP extends string> = MP extends `${method} ${infer P}` ? P : never;
type pathsByMethod<M extends method> = pathByMethod<methodPathsByMethod<M>>;

const hasApiRequest = <PM extends keyof apiSchemaCollection>(args: unknown): args is { data: apiSchemaCollection[PM]["Request"] } => {
  return !!(args as { data: unknown })?.data
};

const hasApiQuery = <PM extends keyof apiSchemaCollection>(args: unknown): args is { query: apiSchemaCollection[PM]["Query"] } => {
  return !!(args as { query: unknown })?.query
};
type pathCallArgs<PM extends keyof apiSchemaCollection> =
  apiSchemaCollection[PM]["Request"] extends undefined
    ? // if Request is undefined
      apiSchemaCollection[PM]["Query"] extends undefined
      ? // if Query is undefined
        Record<string, never>
      : // if Query is defined
        { query: apiSchemaCollection[PM]["Query"] }
    : // if Request is defined
      apiSchemaCollection[PM]["Query"] extends undefined
      ? // if Query is undefined
        { data: apiSchemaCollection[PM]["Request"] }
      : // if Query is defined
        {
            data: apiSchemaCollection[PM]["Request"];
            query: apiSchemaCollection[PM]["Query"];
        };

type client = {
  get: <P extends pathsByMethod<"GET">>(path: P, args: pathCallArgs<`GET ${P}`>) => Promise<apiSchemaCollection[`GET ${P}`]["Response"]>
  post: <P extends pathsByMethod<"POST">>(path: P, args: pathCallArgs<`POST ${P}`>) => Promise<apiSchemaCollection[`POST ${P}`]["Response"]>
};

type myFetcher = (input: string, init: { method: string; headers: Record<string, string>; body: string | undefined; }) => Promise<Response>;

export const newClient = (baseURL = "", myFetch: myFetcher = fetch): client => {
  const fetchByPath = async <PM extends keyof apiSchemaCollection>(method: method, path: string, args: pathCallArgs<PM>) => {
    const builtPath = path;
    const query = hasApiQuery(args) ? `?${new URLSearchParams(args.query).toString()}` : "";
    const body = hasApiRequest(args) ? JSON.stringify(args.data) : undefined;
    const response = await myFetch(baseURL + builtPath + query, {
      method,
      headers: {
        "Content-Type": "application/json",
      },
      body,
    });

    if (!response.ok) {
      try {
        const error = await response.json();
        return error;
      } catch (e) {
        throw new Error(response.statusText);
      }
    }
    return response.json() as Promise<apiSchemaCollection[PM]["Response"]>;
  }
  const get = async <P extends pathsByMethod<"GET">>(path: P, args: pathCallArgs<`GET ${P}`>) => await fetchByPath("GET", path, args);
  const post = async <P extends pathsByMethod<"POST">>(path: P, args: pathCallArgs<`POST ${P}`>) => await fetchByPath("POST", path, args);

  return {
    get,
    post,
  };
};
